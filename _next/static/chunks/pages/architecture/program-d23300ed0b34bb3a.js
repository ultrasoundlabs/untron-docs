(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9005],{732:function(e,s,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/architecture/program",function(){return n(5739)}])},5739:function(e,s,n){"use strict";n.r(s),n.d(s,{__toc:function(){return c}});var o=n(5893),t=n(2673),r=n(8647),i=n(1255);n(9488);var a=n(2643),l=n(8757);let c=[{depth:2,value:"ZK proving STF",id:"zk-proving-stf"},{depth:3,value:"How does it work? What are the private and public inputs?",id:"how-does-it-work-what-are-the-private-and-public-inputs"}];function h(e){let s=Object.assign({h1:"h1",p:"p",a:"a",em:"em",ul:"ul",li:"li",pre:"pre",code:"code",span:"span",h2:"h2",h3:"h3"},(0,a.a)(),e.components);return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(s.h1,{children:"Untron Program (State Transition Function)"}),"\n",(0,o.jsxs)(s.p,{children:["The crucial part of Untron Protocol is its ",(0,o.jsx)(s.a,{href:"https://github.com/ultrasoundlabs/untron/tree/main/program/",children:"ZK program"}),". It is responsible for reading all contents of Tron blocks and filtering out information relevant to orders in Untron Core."]}),"\n",(0,o.jsxs)(s.p,{children:["In some sense, Untron's ZK program is a Rust rewrite of ",(0,o.jsx)(s.a,{href:"https://github.com/tronprotocol/java-tron",children:"Tron's node implementation"}),", with light block verification and Untron-specific logic injected into it. Similarly to other node implementations, Untron Program includes its own state, needed to keep track of all orders and blocks in Tron blockchain, and the State Transition Function (STF). STF accepts the old state, a list of new ",(0,o.jsx)(s.em,{children:"actions"})," and blocks in Tron blockchain, and light-executes these blocks against the new orders to determine which orders were closed (that is, received required amount in USDT TRC20). It then commits to the new state and the list of orders that were closed."]}),"\n",(0,o.jsxs)(s.p,{children:["Untron Program was implemented with ZK-friendliness in mind, so it's feasible to utilize Rust-based zkVMs to generate ZK proofs of its STF and easily verify them onchain. In our case, we utilize ",(0,o.jsx)(s.a,{href:"https://docs.succinct.xyz",children:"SP1 zkVM"}),", but other zkVMs are possible to integrate as well. Generated ZK proofs are then sent to the Core contract for verification, and the respective orders are closed in the system. This way, we power trustless P2P exchange orders between Tron and other blockchains."]}),"\n",(0,o.jsx)(l.G,{chart:'%% Function: stf\n\nflowchart TB\n\n    %% Start of the STF function\n    Start([Start STF function]) --> ProcessActions\n\n    %% Processing New Actions\n    subgraph "Process New Actions"\n        ProcessActions[For each action in execution.actions]\n        ProcessActions --> HashAction[Hash ABI-encoded action to update action_chain]\n        HashAction --> AddToPending[Add action, action_chain to state.pending_actions]\n    end\n\n    AddToPending --> InitializeVariables\n\n    %% Initialize Variables\n    subgraph "Initialize Variables"\n        InitializeVariables[Initialize closed_orders and active_addresses]\n        InitializeVariables --> CalcBlockCount[Calculate block_count]\n        CalcBlockCount --> AssertBlockCount[Assert block_count > ORDER_TTL + 19]\n    end\n\n    AssertBlockCount --> IterateBlocks\n\n    %% Iterate Over Each Block\n    subgraph "Iterate Over Blocks"\n        IterateBlocks[For each block in execution.blocks]\n        IterateBlocks --> ConsensusChecks\n        ConsensusChecks --> UpdateStateCycle\n        UpdateStateCycle --> SkipUnfinalizedBlocks[Check if block is among last 19 blocks]\n        SkipUnfinalizedBlocks --> |Yes| NextBlock\n        SkipUnfinalizedBlocks --> |No| UpdateLatestBlock\n        NextBlock --> IterateBlocks\n        UpdateLatestBlock[Update state.latest_block_id and state.latest_timestamp]\n        UpdateLatestBlock --> ProcessPendingActions\n        ProcessPendingActions --> ProcessBlockTransactions\n        ProcessBlockTransactions --> MaintenancePeriodLogic\n        MaintenancePeriodLogic --> IterateBlocks\n    end\n\n    IterateBlocks --> End[Return closed_orders]\n\n    %% Consensus Checks\n    subgraph "Consensus Checks"\n        ConsensusChecks[Consensus checks for block]\n        ConsensusChecks --> HashBlockData[Hash block.raw_data to get raw_data_hash]\n        HashBlockData --> ParseBlockHeader[Parse block_header using parse_block_header]\n        ParseBlockHeader --> RecoverPublicKey[Recover public key from signature and raw_data_hash]\n        RecoverPublicKey --> GetSRAddress[Convert public key to address sr]\n        GetSRAddress --> AssertSRInList[Assert sr is in state.srs]\n    end\n\n    %% Update State Cycle\n    subgraph "Update State Cycle"\n        UpdateStateCycle[Update state.cycle]\n        UpdateStateCycle --> CycleLengthCheck{Is state.cycle.len == 19?}\n        CycleLengthCheck --> |Yes| RemoveOldestSR[Remove first element from state.cycle]\n        CycleLengthCheck --> |No| CheckSRNotInCycle\n        RemoveOldestSR --> CheckSRNotInCycle[Assert sr not in state.cycle]\n        CheckSRNotInCycle --> AddSRToCycle[Add sr to state.cycle]\n    end\n\n    %% Process Pending Actions\n    subgraph "Process Pending Actions"\n        ProcessPendingActions[Process pending actions]\n        ProcessPendingActions --> PendingActionCheck{Is pending action\'s timestamp <= block_header.timestamp?}\n        PendingActionCheck --> |Yes| RemovePendingAction[Remove first pending action]\n        RemovePendingAction --> CheckActiveAddress{Is action.address in active_addresses?}\n        CheckActiveAddress --> |Yes| CloseOrder\n        CheckActiveAddress --> |No| OpenNewOrder\n        CloseOrder[Close existing order]\n        CloseOrder --> RemoveOrder[Remove order from state.orders and active_addresses]\n        RemoveOrder --> PendingActionCheck\n        OpenNewOrder[Create new order in state.orders]\n        OpenNewOrder --> AddToActiveAddresses[Add action.address to active_addresses]\n        AddToActiveAddresses --> PendingActionCheck\n        PendingActionCheck --> |No| ExitPendingActions\n        ExitPendingActions --> ProcessBlockTransactions\n    end\n\n    %% Process Block Transactions\n    subgraph "Process Block Transactions"\n        ProcessBlockTransactions[Process transactions in block]\n        ProcessBlockTransactions --> ComputeTxHashes[Compute tx_hashes of block.txs]\n        ComputeTxHashes --> VerifyMerkleRoot[Verify Merkle root matches block_header.tx_root]\n        VerifyMerkleRoot --> ForEachTx[For each tx in block.txs]\n        ForEachTx --> IsUSDTTransfer{Is tx a USDT transfer?}\n        IsUSDTTransfer --> |Yes| ProcessUSDTTransfer\n        IsUSDTTransfer --> |No| IsVoteTx\n        IsVoteTx{Is tx a Vote transaction?}\n        IsVoteTx --> |Yes| ProcessVoteTx\n        IsVoteTx --> |No| NextTx\n        ProcessUSDTTransfer --> NextTx\n        ProcessVoteTx --> NextTx\n        NextTx --> ForEachTx\n    end\n\n    %% Process USDT Transfer\n    subgraph "Process USDT Transfer"\n        ProcessUSDTTransfer[Process USDT transfer]\n        ProcessUSDTTransfer --> CheckActiveOrder{Is transfer.to in active_addresses?}\n        CheckActiveOrder --> |Yes| UpdateOrderInflow[Update inflow in state.orders]\n        CheckActiveOrder --> |No| SkipTx\n    end\n\n    %% Process Vote Transaction\n    subgraph "Process Vote Transaction"\n        ProcessVoteTx[Process vote transaction]\n        ProcessVoteTx --> ForEachVote[For each vote in vote_tx.votes]\n        ForEachVote --> UpdateVotes[Update state.votes for vote.witness_address]\n        UpdateVotes --> ForEachVote\n    end\n\n    %% Maintenance Period Logic\n    subgraph "Maintenance Period Logic"\n        MaintenancePeriodLogic[Check for maintenance period]\n        MaintenancePeriodLogic --> IsMaintenanceBlock{Is current block a maintenance block?}\n        IsMaintenanceBlock --> |Yes| CollectVotes[Collect votes from state.votes]\n        CollectVotes --> SortVotes[Sort votes and get top 27 SR candidates]\n        SortVotes --> UpdateSRs[Update state.srs with new SRs]\n        UpdateSRs --> ResetCycleAndVotes[Clear state.cycle and state.votes]\n        IsMaintenanceBlock --> |No| ContinueExecution\n        ContinueExecution --> IterateBlocks\n    end\n\n    %% End of STF Function\n    End'}),"\n",(0,o.jsx)(s.p,{children:"The program contains a large set of logic related to verifying the contents of Tron blocks and maintaining the state of the protocol. But, in short and simplifying, these are the main tasks the program performs:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsx)(s.li,{children:"Maintaining the list of active Super-Representatives (SRs) who are authorized to propose new blocks;"}),"\n",(0,o.jsx)(s.li,{children:"Accepting the list of pending actions from the Core contract and processing them respectively to timestamps of the blocks;"}),"\n",(0,o.jsx)(s.li,{children:"Accepting new Tron blocks, performing the consensus checks for each of them;"}),"\n",(0,o.jsx)(s.li,{children:"Iterating over all transactions in the block, finding USDT transfers related to the active orders in Core and storing updates (inflow) in the state;"}),"\n",(0,o.jsx)(s.li,{children:"Closing orders that received enough USDT;"}),"\n",(0,o.jsx)(s.li,{children:"Every maintenance period (7200 blocks), the program counts all votes for new SRs and updates the list of active SRs."}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsxs)(s.em,{children:["A TL;DR of Tron's consensus from ",(0,o.jsx)(s.a,{href:"https://github.com/ultrasoundlabs/zktron",children:"the first version of Untron program"}),', called "zktron" at the time:']})}),"\n",(0,o.jsx)(s.pre,{"data-language":"text","data-theme":"default",children:(0,o.jsxs)(s.code,{"data-language":"text","data-theme":"default",children:[(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"Tron's consensus mechanism is deadly simple. Every 7200 blocks users delegate their TRX to validators (representatives), and the 27 validators with most votes become Super Representatives - ones who produce blocks. Producer selection is round-robin, and after 18 confirmations (that is, 2/3 of the SR set) the block is considered finalized."})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"}})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"The block production is an ECDSA signature over the SHA256 hash of the protobuf-encoded block header. That is, one block = one signature. This allows us to efficiently generate ZK proofs for light verification of the Tron blockchain. Even though Tron does not merkleize state, transaction root in the block headers is already pretty powerful."})})]})}),"\n",(0,o.jsx)(s.p,{children:"It's worth adding that the transaction root is powerful because we can not only recover all transactions from the block in a ZK proof, but also verify if they were successfully executed. This is possible because all transactions in Tron carry their execution status:"}),"\n",(0,o.jsx)(s.pre,{"data-language":"protobuf","data-theme":"default",children:(0,o.jsxs)(s.code,{"data-language":"protobuf","data-theme":"default",children:[(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"message Transaction {"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"  ..."})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"  message Result {"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    enum code {"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"      SUCESS = 0;"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"      FAILED = 1;"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    }"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    enum contractResult {"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"      DEFAULT = 0;"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"      SUCCESS = 1;"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"      REVERT = 2;"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"      ..."})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    }"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    int64 fee = 1;"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    code ret = 2;"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    contractResult contractRet = 3;"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"..."})})]})}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsxs)(s.em,{children:["(from ",(0,o.jsx)(s.a,{href:"https://github.com/ultrasoundlabs/untron/tree/main/lib/java-tron/protocol/src/main/protos/core/Tron.proto",children:"Tron's Protobuf protocol"}),")"]})}),"\n",(0,o.jsxs)(s.p,{children:["The internals might seem complicated, but Tron's consensus is actually pretty simple. For more details about how it works internally, you can read ",(0,o.jsx)(s.a,{href:"https://github.com/ultrasoundlabs/untron/tree/main/program/src/lib.rs",children:"the program's source code"})," or ",(0,o.jsx)(s.a,{href:"https://github.com/ultrasoundlabs/tron-research/tree/20011157481051903247d4d4fcfdd7f4df77acb1",children:"Tron light client in Python"})," implemented by Alex Hook, the inventor of Untron Protocol. There's ",(0,o.jsx)(s.a,{href:"https://developers.tron.network/docs/concensus",children:"an official documentation of Tron's consensus"}),", but it's not as detailed as the code or this documentation."]}),"\n",(0,o.jsx)(s.h2,{id:"zk-proving-stf",children:"ZK proving STF"}),"\n",(0,o.jsxs)(s.p,{children:["Untron Program's crate implements an executable entry point ",(0,o.jsx)(s.a,{href:"https://github.com/ultrasoundlabs/untron/tree/main/program/src/main.rs",children:"(main.rs)"}),", which allows the program to be compiled into a RISC-V binary and proved via SP1 zkVM. The entry point provides the STF with the list of blocks and actions from the private inputs of the circuit, and runs the STF, returning (committing to) the list of closed orders and prints of the new Program's state to the Core contract for further processing."]}),"\n",(0,o.jsx)(s.pre,{"data-language":"rust","data-theme":"default",children:(0,o.jsxs)(s.code,{"data-language":"rust","data-theme":"default",children:[(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"pub"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"fn"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"main"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"() {"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:"    // read the serialized state from the proof's private inputs"})}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"let"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" serialized_state "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"="}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"read_vec"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"();"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:"    // compute the old state hash"})}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"let"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" old_state_hash "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"="}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" crypto"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"::"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"hash"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"&"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"serialized_state);"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:'    // deserialize the state using "bincode" serialization scheme'})}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"let"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"mut"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" state"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"State"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"="}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" bincode"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"::"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"deserialize"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"&"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"serialized_state)"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"."}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"unwrap"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"();"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:" "}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:"    // read the execution payload from the private inputs"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:"    // INPUT FORMAT:"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:"    // - actions: Vec<u8> (bincode serialized Vec<Order>)"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:"    // - blocks: Vec<u8> (bincode serialized Vec<RawBlock>)"})}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"let"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" execution "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"="}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"Execution"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" {"})]}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"        actions"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" bincode"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"::"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"deserialize"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"&"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"read_vec"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"())"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"."}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"unwrap"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"(),"})]}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"        blocks"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:":"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" bincode"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"::"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"deserialize"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"&"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"read_vec"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"())"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"."}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"unwrap"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"(),"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    };"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:" "}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:"    // get the latest zk proven Tron blockchain's block id and Untron's action chain (chained hash of all actions)"})}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"let"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" old_block_id "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"="}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" state"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"."}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"latest_block_id;"})]}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"let"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" old_action_chain "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"="}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" state"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"."}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"action_chain;"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:" "}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:"    // perform execution over the state through the state transition function (see lib.rs for details)"})}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"let"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" closed_orders "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"="}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"stf"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"&mut"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" state, execution);"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:" "}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:"    // compute the new state hash"})}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"let"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" new_state_hash "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"="}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" crypto"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"::"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"hash"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"&"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"bincode"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"::"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"serialize"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"&"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"state)"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"."}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"unwrap"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"());"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:" "}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"let"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" public_values "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"="}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"UntronPublicValues"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"::"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"abi_encode"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"&"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"("})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"        old_block_id,"})}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"        state"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"."}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"latest_block_id,"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"        old_action_chain,"})}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"        state"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"."}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"action_chain,"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"        old_state_hash,"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"        new_state_hash,"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"        closed_orders,"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    ));"})}),"\n",(0,o.jsx)(s.span,{className:"line",children:" "}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-comment)"},children:"    // commit the public values as public inputs for the zk proof"})}),"\n",(0,o.jsxs)(s.span,{className:"line",children:[(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-function)"},children:"commit_slice"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-token-keyword)"},children:"&"}),(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"public_values);"})]}),"\n",(0,o.jsx)(s.span,{className:"line",children:(0,o.jsx)(s.span,{style:{color:"var(--shiki-color-text)"},children:"}"})})]})}),"\n",(0,o.jsx)(s.p,{children:(0,o.jsxs)(s.em,{children:["(from ",(0,o.jsx)(s.a,{href:"https://github.com/ultrasoundlabs/untron/tree/main/program/src/main.rs",children:"main.rs"})," with some comments changed. Yes, it's actually this tiny.)"]})}),"\n",(0,o.jsx)(s.h3,{id:"how-does-it-work-what-are-the-private-and-public-inputs",children:"How does it work? What are the private and public inputs?"}),"\n",(0,o.jsx)(s.p,{children:"If you're not familiar with the concept of ZK proofs (you really should be, though), you can think of it like this:"}),"\n",(0,o.jsxs)(s.ul,{children:["\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.em,{children:"Public inputs"})," are values known by both the prover (relayer) and the verifier (Core contract). In our case, they're the old and new IDs of Tron blocks, the old and new action chain tips (actions in the Core are chained into hash chains), the old and new state hashes, and the list of closed orders."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.em,{children:"Private inputs"})," are values known only to the prover (relayer). In our case, they're the list of blocks and actions from the Tron blockchain and the list of pending actions from the Untron contract. We store them in private because there is no way we could fit ~2 GB of Tron blocks onchain every day. This is one of the beauties of ZK proofs: the contract doesn't even need to have all data if it's sure that the computation done over them was correct."]}),"\n",(0,o.jsxs)(s.li,{children:[(0,o.jsx)(s.em,{children:"Proof"})," is the data that the prover (relayer) provides to the verifier (Core contract) to prove that the public inputs (info about closed orders) are correct."]}),"\n"]}),"\n",(0,o.jsx)(s.p,{children:"The prover runs the Untron Program with the private inputs, producing the list of closed orders and the new state of the program. Then, it commits to them and provides the contract with a ZK proof that the list of closed orders and the new state of the program are correct against. The verifier runs the Untron Program on the public inputs and checks the ZK proof. If the proof is correct, the verifier accepts the proof and the list of closed orders and the new state of the program as valid."})]})}let d={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:s}=Object.assign({},(0,a.a)(),e.components);return s?(0,o.jsx)(s,{...e,children:(0,o.jsx)(h,{...e})}):h(e)},pageOpts:{filePath:"pages/architecture/program.mdx",route:"/architecture/program",timestamp:1727256887e3,pageMap:[{kind:"Meta",data:{index:"Introduction",navigation:"Getting Started",architecture:"How Untron Works",integrate:"Integrate Untron",contribute:"Contribute to Untron"}},{kind:"Folder",name:"architecture",route:"/architecture",children:[{kind:"Meta",data:{index:"Untron Explained Upside Down",program:"ZK Program",core:"Core Smart Contract",relayer:"Relayer Software",end:"That's it!"}},{kind:"MdxPage",name:"core",route:"/architecture/core"},{kind:"MdxPage",name:"end",route:"/architecture/end"},{kind:"MdxPage",name:"index",route:"/architecture"},{kind:"MdxPage",name:"program",route:"/architecture/program"},{kind:"MdxPage",name:"relayer",route:"/architecture/relayer"}]},{kind:"MdxPage",name:"contribute",route:"/contribute"},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"integrate",route:"/integrate",children:[{kind:"Meta",data:{index:"General Information",contracts:"Untron from Contracts",software:"Untron from Software",api:"Untron.finance API"}},{kind:"MdxPage",name:"api",route:"/integrate/api"},{kind:"MdxPage",name:"contracts",route:"/integrate/contracts"},{kind:"MdxPage",name:"index",route:"/integrate"},{kind:"MdxPage",name:"software",route:"/integrate/software"}]},{kind:"MdxPage",name:"navigation",route:"/navigation"}],flexsearch:{codeblocks:!0},title:"Untron Program (State Transition Function)",headings:c},pageNextRoute:"/architecture/program",nextraLayout:r.ZP,themeConfig:i.Z};s.default=(0,t.j)(d)},1255:function(e,s,n){"use strict";var o=n(5893),t=n(7294),r=n(2010),i=n(5675),a=n.n(i);s.Z={logo:()=>{let{theme:e,resolvedTheme:s}=(0,r.F)(),[n,i]=(0,t.useState)(!1);return((0,t.useEffect)(()=>{i(!0)},[]),n)?(0,o.jsx)("span",{style:{display:"flex",alignItems:"center"},children:(0,o.jsx)(a(),{src:"dark"===("system"===e?s:e)?"/untron-docs/logo/white.png":"/untron-docs/logo/black.png",alt:"Untron Logo",width:128,height:128})}):null},project:{link:"https://github.com/ultrasoundlabs/untron"},docsRepositoryBase:"https://github.com/ultrasoundlabs/untron-docs/blob/main",footer:{text:"Untron Documentation"}}},5789:function(){}},function(e){e.O(0,[5083,387,9856,2888,9774,179],function(){return e(e.s=732)}),_N_E=e.O()}]);