(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[6045],{6708:function(e,r,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/architecture/core",function(){return n(8748)}])},8748:function(e,r,n){"use strict";n.r(r),n.d(r,{__toc:function(){return c}});var s=n(5893),t=n(2673),o=n(8647),a=n(1255);n(9488);var i=n(2643),l=n(8757);let c=[{depth:2,value:"Order Workflow in Untron Core",id:"order-workflow-in-untron-core"},{depth:3,value:"Untron is B2B or why collateral is a good UX",id:"untron-is-b2b-or-why-collateral-is-a-good-ux"},{depth:2,value:"Intron Swaps",id:"intron-swaps"},{depth:2,value:'How come "address"?',id:"how-come-address"}];function d(e){let r=Object.assign({h1:"h1",p:"p",h2:"h2",blockquote:"blockquote",strong:"strong",em:"em",pre:"pre",code:"code",span:"span",a:"a",h3:"h3",ul:"ul",li:"li"},(0,i.a)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.h1,{children:"Untron Core in one breath"}),"\n",(0,s.jsx)(r.p,{children:"Now, let's clean up some accumulated confusion about what Untron Core does and how it works."}),"\n",(0,s.jsx)(r.p,{children:"Untron Core is a smart contract that manages peer-to-peer (P2P) orders between USDT on Tron and its native chainâ€”in our case, ZKsync Era. The orders are P2P because technically people buy and sell USDT for USDT from each other, just on the different chains. To verify the fact of USDT transfer on Tron network, Untron Core utilizes ZK proofs of Untron Program."}),"\n",(0,s.jsx)(r.h2,{id:"order-workflow-in-untron-core",children:"Order Workflow in Untron Core"}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Warning"}),": This diagram is slightly simplified and must not be used for reimplementation or logic auditing."]}),"\n"]}),"\n",(0,s.jsx)(l.G,{chart:"flowchart TD\n    A[Start: Order Creator Wants to Swap USDT Tron to USDT L2]\n\n    %% Step 1: Order Creator Initiates an Order\n    A --> B[Order Creator Calls createOrder]\n\n    %% Step 2: Collect Collateral\n    B --> C[Collect requiredCollateral from Order Creator]\n\n    %% Step 3: Validate Receiver Availability\n    C --> D{Is Receiver Busy?}\n\n    %% If Receiver is Busy\n    D -->|Yes| E{Is Existing Order Expired?}\n    E -->|Yes| F[Free the Receiver]\n    E -->|No| G[Revert: Receiver is busy]\n    G --> H[End]\n\n    %% If Receiver is Not Busy\n    D -->|No| I[Proceed to Validate Receiver Ownership]\n\n    %% Step 4: Validate Receiver Ownership\n    F --> I\n    I --> J{Is Receiver Owned by Provider?}\n    J -->|Yes| K[Proceed to Validate Provider's Liquidity]\n    J -->|No| L[Revert: Receiver is not owned by provider]\n    L --> H\n\n    %% Step 5: Validate Provider's Liquidity\n    K --> M{Does Provider Have Sufficient Liquidity?}\n    M -->|Yes| N[Proceed to Validate Rate Consistency]\n    M -->|No| O[Revert: Provider does not have enough liquidity]\n    O --> H\n\n    %% Step 6: Validate Rate Consistency\n    N --> P{Does Rate Match Provider's Rate?}\n    P -->|Yes| Q[Proceed to Validate Order Size]\n    P -->|No| R[Revert: Rate does not match provider's rate]\n    R --> H\n\n    %% Step 7: Validate Order Size\n    Q --> S{Is Order Size Within Provider's Min and Max Limits?}\n    S -->|Yes| T[Deduct Provider's Liquidity]\n    S -->|No| U[Revert: Order size is out of bounds]\n    U --> H\n\n    %% Step 8: Deduct Provider's Liquidity\n    T --> V[Update Provider's Liquidity Balance]\n\n    %% Step 9: Update Action Chain and Order State\n    V --> W[Update Action Chain]\n    W --> X[Mark Receiver as Busy]\n    X --> Y[Store Order Details]\n    Y --> Z[Emit OrderCreated Event]\n\n    %% Option to Modify or Stop Order\n    Z --> AA{Does Order Creator Want to Modify or Stop Order?}\n    AA -->|Yes| AB{Modify or Stop?}\n    AB -->|Modify| AC[Call changeOrder]\n    AC --> AD{Is Caller the Order Creator and Order Unfulfilled?}\n    AD -->|Yes| AE[Update Order Transfer Details]\n    AD -->|No| AF[Revert: Only creator can change the order]\n    AF --> H\n\n    AB -->|Stop| AG[Call stopOrder]\n    AG --> AH{Is Caller the Order Creator and Order Unfulfilled?}\n    AH -->|Yes| AI[Proceed to Stop Order]\n    AH -->|No| AJ[Revert: Only creator can stop the order]\n    AJ --> H\n\n    %% Stopping an Order\n    AI --> AK[Update Action Chain to Reflect Stop Action]\n    AK --> AL[Refund Provider's Liquidity]\n    AL --> AM[Refund Order Creator's Collateral]\n    AM --> AN[Delete Order]\n    AN --> AO[Emit OrderStopped Event]\n    AO --> H\n\n    %% If No Modification or Stopping\n    AA -->|No| AP[Order Remains Active Until Fulfillment or Expiry]\n\n    %% Step 10: Fulfiller Advances USDT L2\n    AP --> AQ{Does a Fulfiller Decide to Fulfill the Order?}\n    AQ -->|Yes| AR[Fulfiller Calls fulfill]\n    AR --> AS[Collect Total Amount from Fulfiller]\n\n    %% Step 11: Process Each Receiver's Order\n    AS --> AT[For Each Receiver]\n    AT --> AU[Retrieve Active Order]\n    AU --> AV[Calculate Amount and Fee]\n    AV --> AW[Update Expected Total]\n\n    %% Step 12: Validate Fulfillment Amount\n    AW --> AX{Is Total Amount >= Expected Total?}\n    AX -->|Yes| AY[Proceed with Fulfillment]\n    AX -->|No| AZ[Revert: Total does not match]\n    AZ --> H\n\n    %% Step 13: Perform Transfer to Order Creator\n    AY --> BA[Perform Transfer via smartTransfer]\n    BA --> BB[Refund Order Creator's Collateral]\n    BB --> BC[Update Action Chain to Free Receiver]\n    BC --> BD[Update Order to Reflect Fulfillment]\n    BD --> BE[Emit OrderFulfilled Event]\n    BE --> BF{Is There Excess Amount?}\n    BF -->|Yes| BG[Refund Excess to Fulfiller]\n    BG --> BH[Wait for ZK Proof Submission]\n    BF -->|No| BH\n\n    %% Step 14: ZK Proof Submission\n    BH --> BI[Relayer Calls closeOrders with ZK Proof]\n    BI --> BJ[Verify ZK Proof and Public Values]\n\n    %% Step 15: Validate Proof\n    BJ --> BK{Is Proof Valid and Public Values Match State?}\n    BK -->|Yes| BL[Proceed to Process Closed Orders]\n    BK -->|No| BM[Revert: Invalid proof or state mismatch]\n    BM --> H\n\n    %% Step 16: Update Global State\n    BL --> BN[Update blockId, latestExecutedAction, stateHash]\n\n    %% Step 17: Process Each Closed Order\n    BN --> BO[For Each Closed Order]\n    BO --> BP[Retrieve Order Details]\n    BP --> BQ[Calculate minInflow]\n    BQ --> BR[Calculate Amount and Fee]\n    BR --> BS[Update Transfer Details]\n\n    %% Step 18: Transfer Funds Based on Fulfillment Status\n    BS --> BT{Was Order Fulfilled Earlier?}\n    BT -->|Yes| BU[Transfer USDT L2 to Fulfiller]\n    BT -->|No| BV[Transfer USDT L2 to Order Creator]\n\n    %% Step 19: Handle Collateral\n    BV --> BW{Did Order Creator Send USDT Tron?}\n    BW -->|Yes| BX[Refund Collateral to Order Creator]\n    BW -->|No| BY[Slash Collateral, Transfer to Contract Owner]\n    BU --> BX\n\n    %% Step 20: Release Receiver and Delete Order\n    BX --> BZ[Release Receiver if Not Fulfilled]\n    BY --> BZ\n    BZ --> CA[Delete Order from Storage]\n    CA --> CB[Emit OrderClosed Event]\n\n    %% Step 21: Distribute Fees\n    CB --> CC[Transfer Accumulated Fees to Owner]\n\n    %% End\n    CC --> H[End]"}),"\n",(0,s.jsxs)(r.p,{children:["Untron Core natively supports swaps between USDT (used as liquidity) and other tokens through 1inch Aggregator, and cross-chain transfers of these tokens through Across Bridge. This way, as long as there's a way to initiate an ",(0,s.jsx)(r.em,{children:"untron swap"})," on ZKsync Era, users can untron into any token on virtually any chain of the Ethereum ecosystem."]}),"\n",(0,s.jsx)(r.pre,{"data-language":"solidity","data-theme":"default",children:(0,s.jsxs)(r.code,{"data-language":"solidity","data-theme":"default",children:[(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"/// "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"@notice"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:" The order creation function"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"/// "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"@param"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:" provider The address of the liquidity provider owning the Tron receiver address."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"/// "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"@param"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:" receiver The address of the Tron receiver address"})]}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"///                that's used to perform a USDT transfer on Tron."})}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"/// "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"@param"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:" size The maximum size of the order in USDT L2."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"/// "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"@param"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:' rate The "USDT L2 per 1 USDT Tron" rate of the order.'})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"/// "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"@param"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:" transfer The transfer details."})]}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"///                 They'll be used in the fulfill or closeOrders functions to send respective"})}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"///                 USDT L2 to the order creator or convert them into whatever the order creator wants to receive"})}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"///                 for their USDT Tron."})}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"function"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-function)"},children:"createOrder"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"("}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"address"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" provider"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-punctuation)"},children:","}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"address"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" receiver"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-punctuation)"},children:","}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"uint256"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" size"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-punctuation)"},children:","}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"uint256"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" rate"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-punctuation)"},children:","}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"Transfer"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"calldata"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" transfer)"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"external"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:";"})]})]})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.em,{children:["(from ",(0,s.jsx)(r.a,{href:"../contracts/src/interfaces/IUntronCore.sol",children:"IUntronCore.sol"}),")"]})}),"\n",(0,s.jsx)(r.pre,{"data-language":"solidity","data-theme":"default",children:(0,s.jsxs)(r.code,{"data-language":"solidity","data-theme":"default",children:[(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"/// "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"@notice"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:" Struct representing a transfer."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"struct"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-function)"},children:"Transfer"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" {"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// recipient of the transfer"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"address"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" recipient;"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// destination chain ID of the transfer."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// if not equal to the contract's chain ID, Across bridge will be used."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"uint256"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" chainId;"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// Across bridge fee. 0 in case of direct transfer."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"uint256"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" acrossFee;"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// whether to swap USDT to another token before sending to the recipient."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"bool"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" doSwap;"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// address of the token to swap USDT to."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"address"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" outToken;"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// minimum amount of output tokens to receive per 1 USDT L2."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"uint256"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" minOutputPerUSDT;"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// whether the minimum amount of output tokens is fixed."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// if true, the order creator will receive exactly minOutputPerUSDT * amount of output tokens."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// if false, the order creator will receive at least minOutputPerUSDT * amount of output tokens."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"bool"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" fixedOutput;"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// data for the swap. Not used if doSwap is false."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"bytes"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" swapData;"})]}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"}"})})]})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.em,{children:["(from ",(0,s.jsx)(r.a,{href:"../contracts/src/interfaces/IUntronTransfers.sol",children:"IUntronTransfers.sol"}),")"]})}),"\n",(0,s.jsx)(r.p,{children:"To prevent order spamming, Untron Core implements a collateral system, where each order creator is required to send a certain amount of collateral to the contract. This collateral is slashed and sent to the Core controller if the funds for the order were not sent to the receiver and the order wasn't stopped by the creator before expiration (5 minutes)."}),"\n",(0,s.jsx)(r.p,{children:"Untron team aims for the collateral size to be roughly equal to the opportunity cost of creating the order. That is, it's expected to be close to what all parties in the protocol would earn if the created order was properly executed."}),"\n",(0,s.jsx)(r.pre,{"data-language":"solidity","data-theme":"default",children:(0,s.jsx)(r.code,{"data-language":"solidity","data-theme":"default",children:(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"function"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-function)"},children:"requiredCollateral"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"() "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"external"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"view"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"returns"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" ("}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"uint256"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:");"})]})})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.em,{children:["(from ",(0,s.jsx)(r.a,{href:"../contracts/src/interfaces/IUntronCore.sol",children:"IUntronCore.sol"}),")"]})}),"\n",(0,s.jsx)(r.h3,{id:"untron-is-b2b-or-why-collateral-is-a-good-ux",children:"Untron is B2B or why collateral is a good UX"}),"\n",(0,s.jsxs)(r.p,{children:["It's important to keep in mind that Untron is a B2B protocol. In other words, Untron ",(0,s.jsx)(r.em,{children:"Core"})," is not intended for end-users to interact with. Instead, various projects integrating Untron will provide necessary infrastructure for their users to interact with the protocol. For example, the project provides collateral itself and might decide to automatically stop all its unexecuted orders after 3 minutes, rather than 5, to keep their collateral."]}),"\n",(0,s.jsxs)(r.p,{children:["The best, albeit not the most obvious, example of such integration is ",(0,s.jsx)(r.a,{href:"https://untron.finance",children:"Untron.finance"}),"â€”the official frontend for Untron, built by Untron team. Untron.finance provides a straightforward interface to swap between USDT Tron from any wallet and chain without any collateral. Instead, it uses advanced internal logic to rate-limit dishonest users and prevent them from spamming orders. Therefore, from the technical point of view, Untron.finance is just one of the projects that utilizes Untron for its operations. If Untron.finance goes down, users can come to an alternative frontend, when such will be made, or use projects that integrate Untron directlyâ€”",(0,s.jsx)(r.a,{href:"https://getclave.com",children:"Clave"}),", ",(0,s.jsx)(r.a,{href:"https://daimo.com",children:"Daimo"}),", ",(0,s.jsx)(r.a,{href:"https://peanut.to",children:"Peanut"}),", and moreâ€”to perform swaps through them."]}),"\n",(0,s.jsx)(l.G,{chart:"flowchart TD\n    subgraph Untron Protocol\n        UntronCore[Untron Core]\n    end\n\n    Project1[Untron.finance] --> UntronCore\n    User1[End User] --> Project1\n    User2[End User] --> Project1\n    User3[End User] --> Project1\n    Project2[Nortnu Alternative Frontend] --> UntronCore\n    User4[End User] --> Project2\n    User5[End User] --> Project2\n    User6[End User] --> Project2\n    Project3[Clave] --> UntronCore\n    User7[End User] --> Project3\n    User8[End User] --> Project3\n    User9[End User] --> Project3"}),"\n",(0,s.jsx)(r.h2,{id:"intron-swaps",children:"Intron Swaps"}),"\n",(0,s.jsx)(r.p,{children:'Besides so-called "untron swaps"â€”swaps from Tron to Ethereum ecosystem, Untron Core supports "intron swaps", the reverse. In the codebase\'s comments, they\'re sometimes referred to as "reversed swaps", since in them the user is actually a one-time liquidity provider that forces order creators to send the entire amount in a single USDT TRC20 transfer, and the order creators are automated entities, called "autocreators". This is how Untron can support two-way swaps with only one-way state verification.'}),"\n",(0,s.jsxs)(r.blockquote,{children:["\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Important:"})," Autocreators, unlike relayers and fulfillers, are not considered the part of the protocol. Therefore, the implementation of them is up to the users willing to participate as intron swap executors. Untron team is not responsible for any external implementations of out-protocol actors, but ",(0,s.jsx)(r.a,{href:"https://github.com/ultrasoundlabs/untron/tree/main/autocreator",children:"does provide the PoC implementation of an autocreator in Python"}),". It's outside the scope of our audits and not suitable for production use."]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{"data-language":"solidity","data-theme":"default",children:(0,s.jsxs)(r.code,{"data-language":"solidity","data-theme":"default",children:[(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-keyword)"},children:"struct"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-function)"},children:"Provider"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" {"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// in USDT L2 (ZKsync Era)"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"uint256"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" liquidity;"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// in USDT L2 (ZKsync Era) per 1 USDT TRC20"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"uint256"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" rate;"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// in USDT TRC20"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"uint256"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" minOrderSize; "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// this is either manually set value or protocol-enforced one"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// in USDT TRC20"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"uint256"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:" minDeposit; "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// normally, this is 0. In intron swaps, this is equal to minOrderSize."})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-comment)"},children:"// Tron addresses to receive the USDT TRC20 from the order creators"})]}),"\n",(0,s.jsxs)(r.span,{className:"line",children:[(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"    "}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-token-constant)"},children:"address"}),(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"[] receivers;"})]}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"}"})})]})}),"\n",(0,s.jsx)(r.p,{children:(0,s.jsxs)(r.em,{children:["(from ",(0,s.jsx)(r.a,{href:"../contracts/src/interfaces/IUntronCore.sol",children:"IUntronCore.sol"}),"; comments are changed to fit the context)"]})}),"\n",(0,s.jsx)(r.h2,{id:"how-come-address",children:'How come "address"?'}),"\n",(0,s.jsxs)(r.p,{children:["You might have noticed that Untron's codebase utilizes ",(0,s.jsx)(r.code,{children:"address"})," Solidity type, 20 bytes long, to store Tron addresses. This is not fundamentally wrongâ€”Tron addresses are also last 20 bytes of a Keccak256 hash of a secp256k1 public keyâ€”but in the Tron protocol, all addresses are prefixed with ",(0,s.jsx)(r.code,{children:"0x41"})," byte (which gives them T... prefix in Base58Check encoding). In our codebase, we don't use this prefix, so all Tron addresses are stored in 20-byte arrays or equivalent types. This was done for two main reasons:"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Simpler integration of Untron with Ethereum-centric libraries;"}),"\n",(0,s.jsxs)(r.li,{children:["Some projects use Ethereum-centric libraries (ethers, web3, etc.) for interaction with USDT TRC20 smart contract, as it uses ",(0,s.jsx)(r.code,{children:"address"})," type too. Therefore, in transfer calldata, we can notice that some transfers insert 20-byte addresses, while some insert prefixed ones. This by default would lead to address mismatch (the same address could have 0x00... and 0x41... slots), and the necessary measures to prevent it would make the codebase less easy to understand."]}),"\n"]}),"\n",(0,s.jsx)(r.pre,{"data-language":"text","data-theme":"default",children:(0,s.jsxs)(r.code,{"data-language":"text","data-theme":"default",children:[(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"transfer(address,uint256)"})}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"CALLDATA:       NOTHING \\/"})}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"0xa9059cbb              [][  EVM ADDRESS; READ BY THE CONTRACT   ]"})}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"0x000000000000000000000000deadbeef12345678bad455b00b5deadbeef12345"})}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"0x0000000000000000000000000000000000000000000000000000000000000001"})})]})}),"\n",(0,s.jsx)(r.pre,{"data-language":"text","data-theme":"default",children:(0,s.jsxs)(r.code,{"data-language":"text","data-theme":"default",children:[(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"transfer(address,uint256)"})}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"CALLDATA:   TRON PREFIX \\/ NOT USED BY THE CONTRACT"})}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"0xa9059cbb              [][  EVM ADDRESS; READ BY THE CONTRACT   ]"})}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"0x000000000000000000000041deadbeef12345678bad455b00b5deadbeef12345"})}),"\n",(0,s.jsx)(r.span,{className:"line",children:(0,s.jsx)(r.span,{style:{color:"var(--shiki-color-text)"},children:"0x0000000000000000000000000000000000000000000000000000000000000001"})})]})})]})}let h={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:r}=Object.assign({},(0,i.a)(),e.components);return r?(0,s.jsx)(r,{...e,children:(0,s.jsx)(d,{...e})}):d(e)},pageOpts:{filePath:"pages/architecture/core.mdx",route:"/architecture/core",timestamp:1727256887e3,pageMap:[{kind:"Meta",data:{index:"Introduction",navigation:"Getting Started",architecture:"How Untron Works",integrate:"Integrate Untron",contribute:"Contribute to Untron"}},{kind:"Folder",name:"architecture",route:"/architecture",children:[{kind:"Meta",data:{index:"Untron Explained Upside Down",program:"ZK Program",core:"Core Smart Contract",relayer:"Relayer Software",end:"That's it!"}},{kind:"MdxPage",name:"core",route:"/architecture/core"},{kind:"MdxPage",name:"end",route:"/architecture/end"},{kind:"MdxPage",name:"index",route:"/architecture"},{kind:"MdxPage",name:"program",route:"/architecture/program"},{kind:"MdxPage",name:"relayer",route:"/architecture/relayer"}]},{kind:"MdxPage",name:"contribute",route:"/contribute"},{kind:"MdxPage",name:"index",route:"/"},{kind:"Folder",name:"integrate",route:"/integrate",children:[{kind:"Meta",data:{index:"General Information",contracts:"Untron from Contracts",software:"Untron from Software",api:"Untron.finance API"}},{kind:"MdxPage",name:"api",route:"/integrate/api"},{kind:"MdxPage",name:"contracts",route:"/integrate/contracts"},{kind:"MdxPage",name:"index",route:"/integrate"},{kind:"MdxPage",name:"software",route:"/integrate/software"}]},{kind:"MdxPage",name:"navigation",route:"/navigation"}],flexsearch:{codeblocks:!0},title:"Untron Core in one breath",headings:c},pageNextRoute:"/architecture/core",nextraLayout:o.ZP,themeConfig:a.Z};r.default=(0,t.j)(h)},1255:function(e,r,n){"use strict";var s=n(5893),t=n(7294),o=n(2010),a=n(5675),i=n.n(a);r.Z={logo:()=>{let{theme:e,resolvedTheme:r}=(0,o.F)(),[n,a]=(0,t.useState)(!1);return((0,t.useEffect)(()=>{a(!0)},[]),n)?(0,s.jsx)("span",{style:{display:"flex",alignItems:"center"},children:(0,s.jsx)(i(),{src:"dark"===("system"===e?r:e)?"/untron-docs/logo/white.png":"/untron-docs/logo/black.png",alt:"Untron Logo",width:128,height:128})}):null},project:{link:"https://github.com/ultrasoundlabs/untron"},docsRepositoryBase:"https://github.com/ultrasoundlabs/untron-docs/blob/main",footer:{text:"Untron Documentation"}}},5789:function(){}},function(e){e.O(0,[5083,387,9856,2888,9774,179],function(){return e(e.s=6708)}),_N_E=e.O()}]);