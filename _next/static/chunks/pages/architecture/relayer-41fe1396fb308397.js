(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[957],{3192:function(e,t,n){(window.__NEXT_P=window.__NEXT_P||[]).push(["/architecture/relayer",function(){return n(5690)}])},5690:function(e,t,n){"use strict";n.r(t),n.d(t,{__toc:function(){return l}});var r=n(5893),o=n(2673),a=n(8647),i=n(1255);n(9488);var c=n(2643);let l=[];function s(e){let t=Object.assign({h1:"h1",p:"p",ol:"ol",li:"li",code:"code",blockquote:"blockquote",strong:"strong",em:"em"},(0,c.a)(),e.components);return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{children:"So, how the Relayer actually works?"}),"\n",(0,r.jsx)(t.p,{children:"The Relayer is constantly connected to two sources of information:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Tron blockchain, through gRPC API of its node;"}),"\n",(0,r.jsx)(t.li,{children:"Untron Core, using ZKsync Era's JSON-RPC API."}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"Both sources are used by the Relayer to fetch and compute over the data in the following way:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"The Relayer fetches the latest ZK proven Tron block ID and the corresponding action chain tip from the Core contract;"}),"\n",(0,r.jsx)(t.li,{children:"The Relayer walks to deeper blocks to reconstruct the state which print is set up in the Core;"}),"\n",(0,r.jsx)(t.li,{children:"After reconstructing the state, the Relayer fetches all actions and Tron blocks after the latest ZK proven ones and fetches new ones;"}),"\n",(0,r.jsx)(t.li,{children:"Every Tron block, it executes a STF with new pending actions to update its local state copy. All locally executed blocks and actions are stored in the buffer;"}),"\n",(0,r.jsx)(t.li,{children:"If the STF execution resulted in closed orders, the Relayer passes them to the Fulfiller thread;"}),"\n",(0,r.jsxs)(t.li,{children:["The Fulfiller thread calls ",(0,r.jsx)(t.code,{children:"calculateFulfillerTotal"})," view function that returns the balance in USDT on ZKsync Era it must have, passing one order back in the buffer and re-calling the function until their balance is enough (if it wasn't enough since the first call);"]}),"\n",(0,r.jsxs)(t.li,{children:["With the number returned by ",(0,r.jsx)(t.code,{children:"calculateFulfillerTotal"})," function, the Fulfiller thread calls ",(0,r.jsx)(t.code,{children:"fulfill"})," function with those orders to transfer the USDT to the order creators;"]}),"\n",(0,r.jsx)(t.li,{children:"After the buffer has reached the size specified in the configuration, the Relayer generates a ZK proof for the STF with the buffer as the input;"}),"\n",(0,r.jsxs)(t.li,{children:["The Relayer sends the ZK proof to the Core contract on ZKsync Era by calling ",(0,r.jsx)(t.code,{children:"closeOrders"})," function;"]}),"\n",(0,r.jsx)(t.li,{children:"The Core contract verifies the ZK proof and the public inputs, and if everything is correct, it marks all orders in the public inputs as closed and the Relayer repeats the process from step 3."}),"\n"]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.strong,{children:"Warning:"})," Even though the situation of the Relayer's account not having enough USDT to fulfill orders is handled, the situation when the Relayer's ZKsync account doesn't have enough balance to pay for ",(0,r.jsx)(t.em,{children:"the gas"})," of the ",(0,r.jsx)(t.code,{children:"closeOrders"})," and ",(0,r.jsx)(t.code,{children:"fulfill"})," calls is ",(0,r.jsx)(t.em,{children:"not handled"})," and will cause things to go wrong."]}),"\n"]})]})}let h={MDXContent:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:t}=Object.assign({},(0,c.a)(),e.components);return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(s,{...e})}):s(e)},pageOpts:{filePath:"pages/architecture/relayer.mdx",route:"/architecture/relayer",timestamp:1727208766e3,pageMap:[{kind:"Meta",data:{index:"Introduction",navigation:"Getting Started",architecture:"How Untron Works",integrate:"Integrate Untron",contribute:"Contribute"}},{kind:"Folder",name:"architecture",route:"/architecture",children:[{kind:"Meta",data:{index:"Untron Explained Upside Down",program:"ZK Program",core:"Core Smart Contract",relayer:"Relayer Software",end:"That's it!"}},{kind:"MdxPage",name:"core",route:"/architecture/core"},{kind:"MdxPage",name:"end",route:"/architecture/end"},{kind:"MdxPage",name:"index",route:"/architecture"},{kind:"MdxPage",name:"program",route:"/architecture/program"},{kind:"MdxPage",name:"relayer",route:"/architecture/relayer"}]},{kind:"MdxPage",name:"contribute",route:"/contribute"},{kind:"MdxPage",name:"index",route:"/"},{kind:"MdxPage",name:"integrate",route:"/integrate"},{kind:"MdxPage",name:"navigation",route:"/navigation"}],flexsearch:{codeblocks:!0},title:"So, how the Relayer actually works?",headings:l},pageNextRoute:"/architecture/relayer",nextraLayout:a.ZP,themeConfig:i.Z};t.default=(0,o.j)(h)},1255:function(e,t,n){"use strict";var r=n(5893),o=n(7294),a=n(2010),i=n(5675),c=n.n(i);t.Z={logo:()=>{let{theme:e,resolvedTheme:t}=(0,a.F)(),[n,i]=(0,o.useState)(!1);return((0,o.useEffect)(()=>{i(!0)},[]),n)?(0,r.jsx)("span",{style:{display:"flex",alignItems:"center"},children:(0,r.jsx)(c(),{src:"dark"===("system"===e?t:e)?"/static/logo/white.png":"/static/logo/black.png",alt:"Untron Logo",width:128,height:128})}):null},project:{link:"https://github.com/ultrasoundlabs/untron"},docsRepositoryBase:"https://github.com/ultrasoundlabs/untron-docs/blob/main",footer:{text:"Untron Documentation"}}},5789:function(){}},function(e){e.O(0,[387,888,774,179],function(){return e(e.s=3192)}),_N_E=e.O()}]);