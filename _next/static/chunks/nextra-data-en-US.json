{"/architecture/core":{"title":"Untron Core in one breath","data":{"":"Now, let's clean up some accumulated confusion about what Untron Core does and how it works.Untron Core is a smart contract that manages peer-to-peer (P2P) orders between USDT on Tron and its native chain—in our case, ZKsync Era. The orders are P2P because technically people buy and sell USDT for USDT from each other, just on the different chains. To verify the fact of USDT transfer on Tron network, Untron Core utilizes ZK proofs of Untron Program.","order-workflow-in-untron-core#Order Workflow in Untron Core":"Warning: This diagram is slightly simplified and must not be used for reimplementation or logic auditing.\nUntron Core natively supports swaps between USDT (used as liquidity) and other tokens through 1inch Aggregator, and cross-chain transfers of these tokens through Across Bridge. This way, as long as there's a way to initiate an untron swap on ZKsync Era, users can untron into any token on virtually any chain of the Ethereum ecosystem.\n/// @notice The order creation function\n/// @param provider The address of the liquidity provider owning the Tron receiver address.\n/// @param receiver The address of the Tron receiver address\n///                that's used to perform a USDT transfer on Tron.\n/// @param size The maximum size of the order in USDT L2.\n/// @param rate The \"USDT L2 per 1 USDT Tron\" rate of the order.\n/// @param transfer The transfer details.\n///                 They'll be used in the fulfill or closeOrders functions to send respective\n///                 USDT L2 to the order creator or convert them into whatever the order creator wants to receive\n///                 for their USDT Tron.\nfunction createOrder(address provider, address receiver, uint256 size, uint256 rate, Transfer calldata transfer)\n    external;\n(from IUntronCore.sol)\n/// @notice Struct representing a transfer.\nstruct Transfer {\n    // recipient of the transfer\n    address recipient;\n    // destination chain ID of the transfer.\n    // if not equal to the contract's chain ID, Across bridge will be used.\n    uint256 chainId;\n    // Across bridge fee. 0 in case of direct transfer.\n    uint256 acrossFee;\n    // whether to swap USDT to another token before sending to the recipient.\n    bool doSwap;\n    // address of the token to swap USDT to.\n    address outToken;\n    // minimum amount of output tokens to receive per 1 USDT L2.\n    uint256 minOutputPerUSDT;\n    // whether the minimum amount of output tokens is fixed.\n    // if true, the order creator will receive exactly minOutputPerUSDT * amount of output tokens.\n    // if false, the order creator will receive at least minOutputPerUSDT * amount of output tokens.\n    bool fixedOutput;\n    // data for the swap. Not used if doSwap is false.\n    bytes swapData;\n}\n(from IUntronTransfers.sol)To prevent order spamming, Untron Core implements a collateral system, where each order creator is required to send a certain amount of collateral to the contract. This collateral is slashed and sent to the Core controller if the funds for the order were not sent to the receiver and the order wasn't stopped by the creator before expiration (5 minutes).Untron team aims for the collateral size to be roughly equal to the opportunity cost of creating the order. That is, it's expected to be close to what all parties in the protocol would earn if the created order was properly executed.\nfunction requiredCollateral() external view returns (uint256);\n(from IUntronCore.sol)","untron-is-b2b-or-why-collateral-is-a-good-ux#Untron is B2B or why collateral is a good UX":"It's important to keep in mind that Untron is a B2B protocol. In other words, Untron Core is not intended for end-users to interact with. Instead, various projects integrating Untron will provide necessary infrastructure for their users to interact with the protocol. For example, the project provides collateral itself and might decide to automatically stop all its unexecuted orders after 3 minutes, rather than 5, to keep their collateral.The best, albeit not the most obvious, example of such integration is Untron.finance—the official frontend for Untron, built by Untron team. Untron.finance provides a straightforward interface to swap between USDT Tron from any wallet and chain without any collateral. Instead, it uses advanced internal logic to rate-limit dishonest users and prevent them from spamming orders. Therefore, from the technical point of view, Untron.finance is just one of the projects that utilizes Untron for its operations. If Untron.finance goes down, users can come to an alternative frontend, when such will be made, or use projects that integrate Untron directly—Clave, Daimo, Peanut, and more—to perform swaps through them.","intron-swaps#Intron Swaps":"TODO: In the first iteration of Untron, Untron V1 was used to perform swaps in both sides. We implemented Untron Intents, a second, multi-chain protocol in the Untron ecosystem, that significantly improved UX for intron swaps. However, its documentation is still in progress. If you want to learn more about them now, please reach out to us."}},"/architecture/end":{"title":"That's it!","data":{"":"You've reached the end of this explainer. Congratulations! If you understood anything, we appreciate it. If you didn't, feel free to reach out to us at any contacts you'll find in these docs.If you want to see the code, you can find it here. If you want to start using Untron, try out Untron.finance website. If you'd rather keep reading, take a look at Integrate Untron section."}},"/architecture":{"title":"How Untron works","data":{"":"Although seeming not obvious at all, we decided to start this deep dive into Untron protocol from its relayer software. Why? Well, Untron's relayer is, in fact, the thing that runs Untron. It's connected to all critical components of the protocol and orchestrates its operation. Therefore, we can start by explaining how the Relayer connects things you don't yet understand, and then move on to explaining those things.Firstly, let's outline three main rules Untron relayer was built according to:\nRelayer is a starter. Therefore, all it must do is to start things that are already working properly when started;\nFrom this it follows that the Relayer must not be the source of trust—the worst thing it could do to the protocol is to go down and cause a liveness failure;\nTo minimize the risk of and the damage from a potential liveness failure, the Relayer must be permissionless and relatively simple to run.\nSimplifying, all the Relayer does is generate ZK proofs of the state transition function of Untron Protocol and send them to the Core contract. This task is permissionless, and anyone can run the relayer, provided they can afford the cost of ZK proof generation.","relayers-and-fulfillers#Relayers and Fulfillers":"Besides relaying, relayer-the-crate implements a Fulfiller. Fulfillers advance funds for orders that were already executed (sent USDT Tron for), but this fact was not yet ZK proven onchain. If some order was fulfilled, it means that its beneficiary (could be order creator, but not necessarily; see later) has already received its ask on the destination chain after sending USDT Tron, but the Core contract doesn't yet know they did send it. This is because one of the Fulfillers had sent the ask in advance, after seeing that the transfer did indeed happen on Tron blockchain.Fulfillers carry the risk of Tron blockchain's reorgs and wait for the ZK proof to get their funds back, in exchange for a small fee. Similarly to relaying tasks, fulfillers are not the source of trust, and the worst that can happen if there are no fulfillers live is that the users will receive their funds in about 30 minutes rather than a few seconds. Considering the Tron blockchain has never reorged in its entire history, this risk is negligible.","relayer-softwares-logic#Relayer Software's Logic":"Now, let's break it down step by step.","initialization#Initialization":"The relayer is initialized with a configuration file (config.toml), which contains the following parameters:\nethereum.rpc_url: The URL of the ZKsync Era RPC node.\nethereum.private_key: The private key of the relayer account on ZKsync Era network.\nethereum.core_address: The address of the Untron Core contract on ZKsync Era network.\ntron.rpc_url: The URL of Tron gRPC node API.\nbuffer.max_blocks: The maximum number of new Tron blocks to initiate ZK proof generation. 0 if no limit.\nbuffer.max_actions: The maximum number of new Untron actions to initiate ZK proof generation. 0 if no limit.\nbuffer.min_interval: The minimum interval between two consecutive ZK proof generations in seconds. 0 if no interval.\n[ethereum]\nrpc_url = \"https://mainnet.era.zksync.io\"\nprivate_key = \"\"\ncore_address = \"0x1234567890123456789012345678901234567890\"\n[tron]\nrpc_url = \"https://api.trongrid.io/jsonrpc\"\n[buffer]\nmax_blocks = 200\nmax_actions = 100\nmin_interval = 10\nAn example configuration file.","buildrs#Build.rs":"Before initializing all modules, the Relayer initiates an SP1 zkVM prover instance. It generates Groth16 ZK proofs of State Transition Function (STF) and sends them to the Core contract from the relayer's account. To initiate the prover, the Relayer compiles untron-program into SP1 zkVM target binary in Docker mode to ensure the ZK program is always the same given the same source code.\nuse sp1_build::{build_program_with_args, BuildArgs};\n// Protobuf-related imports\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    // Protobuf compilation logic above\n    println!(\"Building ZK program, make sure Docker is running...\");\n    let args = BuildArgs {\n        docker: true,\n        output_directory: \"./elf\".to_string(),\n        ..Default::default()\n    };\n    build_program_with_args(\"../program\", args);\n    Ok(())\n}\n(from build.rs)This compilation of untron-program should not be confused with constant calling of the State Transition Function from it. Besides compiling the program as an executable, the Relayer imports its STF as a dependency crate, getting rid of the overhead from initializing SP1 environment every Tron block.\ntracing::info!(\"Executing state transition function...\");\nlet _ = untron_program::stf(\n    &mut state,\n    Execution {\n        actions: self.get_latest_actions().await?,\n        blocks,\n    },\n);\ntracing::info!(\"State transition function executed\");\nlet state_hash = hash(&bincode::serialize(&state).unwrap());\ntracing::info!(\"State hash: {:?}\", hex::encode(state_hash));\nlet contract_state_hash = self.contract.state_hash().call().await?;\nif state_hash != contract_state_hash {\n    panic!(\n        \"State hash mismatch: {} != {}. This might be the case of Core's misconfiguration or a bug in the relayer. If you think it's the latter, please report it to the developers.\",\n        hex::encode(state_hash),\n        hex::encode(contract_state_hash)\n    );\n}\n(from main.rs)Configuration values under tron are used to initiate TronModule. Besides the gRPC URL in it, TronModule requires compiled Tron Protobuf files to decode Tron transactions. They're compiled in build.rs using tonic-build crate. Untron's repository includes Tron Protocol as a git submodule, so it's necessary to initialize all submodules before building the Relayer.\n// ZK-related imports\nuse std::fs;\nuse std::io;\nuse std::path::Path;\nfn copy_dir_all(src: impl AsRef<Path>, dst: impl AsRef<Path>) -> io::Result<()> {\n    fs::create_dir_all(&dst)?;\n    for entry in fs::read_dir(src)? {\n        let entry = entry?;\n        let ty = entry.file_type()?;\n        if ty.is_dir() {\n            copy_dir_all(entry.path(), dst.as_ref().join(entry.file_name()))?;\n        } else {\n            fs::copy(entry.path(), dst.as_ref().join(entry.file_name()))?;\n        }\n    }\n    Ok(())\n}\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    println!(\n        \"Building Tron protocol... If it fails, make sure you initialized submodules in this repo.\"\n    );\n    copy_dir_all(\n        Path::new(\"../lib/googleapis/google\"),\n        Path::new(\"../lib/java-tron/protocol/src/main/protos/google\"),\n    )?;\n    tonic_build::configure()\n        .build_server(false)\n        .boxed(\"BlockExtention\")\n        .compile(\n            &[\"../lib/java-tron/protocol/src/main/protos/api/api.proto\"],\n            &[\"../lib/java-tron/protocol/src/main/protos\"],\n        )?;\n    fs::remove_dir_all(\"../lib/java-tron/protocol/src/main/protos/google\")?;\n    // ZK program compilation logic below\n}\n(from build.rs)"}},"/architecture/program":{"title":"Untron Program (State Transition Function)","data":{"":"The crucial part of Untron Protocol is its ZK program. It is responsible for reading all contents of Tron blocks and filtering out information relevant to orders in Untron Core.In some sense, Untron's ZK program is a Rust rewrite of Tron's node implementation, with light block verification and Untron-specific logic injected into it. Similarly to other node implementations, Untron Program includes its own state, needed to keep track of all orders and blocks in Tron blockchain, and the State Transition Function (STF). STF accepts the old state, a list of new actions and blocks in Tron blockchain, and light-executes these blocks against the new orders to determine which orders were closed (that is, received required amount in USDT TRC20). It then commits to the new state and the list of orders that were closed.Untron Program was implemented with ZK-friendliness in mind, so it's feasible to utilize Rust-based zkVMs to generate ZK proofs of its STF and easily verify them onchain. In our case, we utilize SP1 zkVM, but other zkVMs are possible to integrate as well. Generated ZK proofs are then sent to the Core contract for verification, and the respective orders are closed in the system. This way, we power trustless P2P exchange orders between Tron and other blockchains.\nThe program contains a large set of logic related to verifying the contents of Tron blocks and maintaining the state of the protocol. But, in short and simplifying, these are the main tasks the program performs:\nMaintaining the list of active Super-Representatives (SRs) who are authorized to propose new blocks;\nAccepting the list of pending actions from the Core contract and processing them respectively to timestamps of the blocks;\nAccepting new Tron blocks, performing the consensus checks for each of them;\nIterating over all transactions in the block, finding USDT transfers related to the active orders in Core and storing updates (inflow) in the state;\nClosing orders that received enough USDT;\nEvery maintenance period (7200 blocks), the program counts all votes for new SRs and updates the list of active SRs.\nA TL;DR of Tron's consensus from the first version of Untron program, called \"zktron\" at the time:\nTron's consensus mechanism is deadly simple. Every 7200 blocks users delegate their TRX to validators (representatives), and the 27 validators with most votes become Super Representatives - ones who produce blocks. Producer selection is round-robin, and after 18 confirmations (that is, 2/3 of the SR set) the block is considered finalized.\nThe block production is an ECDSA signature over the SHA256 hash of the protobuf-encoded block header. That is, one block = one signature. This allows us to efficiently generate ZK proofs for light verification of the Tron blockchain. Even though Tron does not merkleize state, transaction root in the block headers is already pretty powerful.\nIt's worth adding that the transaction root is powerful because we can not only recover all transactions from the block in a ZK proof, but also verify if they were successfully executed. This is possible because all transactions in Tron carry their execution status:\nmessage Transaction {\n  ...\n  message Result {\n    enum code {\n      SUCESS = 0;\n      FAILED = 1;\n    }\n    enum contractResult {\n      DEFAULT = 0;\n      SUCCESS = 1;\n      REVERT = 2;\n      ...\n    }\n    int64 fee = 1;\n    code ret = 2;\n    contractResult contractRet = 3;\n...\n(from Tron's Protobuf protocol)The internals might seem complicated, but Tron's consensus is actually pretty simple. For more details about how it works internally, you can read the program's source code or Tron light client in Python implemented by Alex Hook, the inventor of Untron Protocol. There's an official documentation of Tron's consensus, but it's not as detailed as the code or this documentation.","zk-proving-stf#ZK proving STF":"Untron Program's crate implements an executable entry point (main.rs), which allows the program to be compiled into a RISC-V binary and proved via SP1 zkVM. The entry point provides the STF with the list of blocks and actions from the private inputs of the circuit, and runs the STF, returning (committing to) the list of closed orders and prints of the new Program's state to the Core contract for further processing.\npub fn main() {\n    // read the serialized state from the proof's private inputs\n    let serialized_state = read_vec();\n    // compute the old state hash\n    let old_state_hash = crypto::hash(&serialized_state);\n    // deserialize the state using \"bincode\" serialization scheme\n    let mut state: State = bincode::deserialize(&serialized_state).unwrap();\n    // read the execution payload from the private inputs\n    // INPUT FORMAT:\n    // - actions: Vec<u8> (bincode serialized Vec<Order>)\n    // - blocks: Vec<u8> (bincode serialized Vec<RawBlock>)\n    let execution = Execution {\n        actions: bincode::deserialize(&read_vec()).unwrap(),\n        blocks: bincode::deserialize(&read_vec()).unwrap(),\n    };\n    // get the latest zk proven Tron blockchain's block id and Untron's action chain (chained hash of all actions)\n    let old_block_id = state.latest_block_id;\n    let old_action_chain = state.action_chain;\n    // perform execution over the state through the state transition function (see lib.rs for details)\n    let closed_orders = stf(&mut state, execution);\n    // compute the new state hash\n    let new_state_hash = crypto::hash(&bincode::serialize(&state).unwrap());\n    let public_values = UntronPublicValues::abi_encode(&(\n        old_block_id,\n        state.latest_block_id,\n        old_action_chain,\n        state.action_chain,\n        old_state_hash,\n        new_state_hash,\n        closed_orders,\n    ));\n    // commit the public values as public inputs for the zk proof\n    commit_slice(&public_values);\n}\n(from main.rs with some comments changed. Yes, it's actually this tiny.)","how-does-it-work-what-are-the-private-and-public-inputs#How does it work? What are the private and public inputs?":"If you're not familiar with the concept of ZK proofs (you really should be, though), you can think of it like this:\nPublic inputs are values known by both the prover (relayer) and the verifier (Core contract). In our case, they're the old and new IDs of Tron blocks, the old and new action chain tips (actions in the Core are chained into hash chains), the old and new state hashes, and the list of closed orders.\nPrivate inputs are values known only to the prover (relayer). In our case, they're the list of blocks from the Tron blockchain and the list of pending actions from the Untron contract. We store them in private because there is no way we could fit ~2 GB of Tron blocks onchain every day. This is one of the beauties of ZK proofs: the contract doesn't even need to have all data if it's sure that the computation done over them was correct.\nProof is the data that the prover (relayer) provides to the verifier (Core contract) to prove that the public inputs (info about closed orders) are correct.\nThe prover runs the Untron Program with the private inputs, producing the list of closed orders and the new state of the program. Then, it commits to them and provides the contract with a ZK proof that the list of closed orders and the new state of the program are correct against. The verifier runs the Untron Program on the public inputs and checks the ZK proof. If the proof is correct, the verifier accepts the proof and the list of closed orders and the new state of the program as valid."}},"/architecture/relayer":{"title":"So, how does the Relayer actually work?","data":{"":"The Relayer is constantly connected to two sources of information:\nTron blockchain, through gRPC API of its node;\nUntron Core, using ZKsync Era's JSON-RPC API.\nBoth sources are used by the Relayer to fetch and compute over the data in the following way:\nThe Relayer fetches the latest ZK proven Tron block ID and the corresponding action chain tip from the Core contract;\nThe Relayer walks to deeper blocks to reconstruct the state which print is set up in the Core;\nAfter reconstructing the state, the Relayer fetches all actions and Tron blocks after the latest ZK proven ones and fetches new ones;\nEvery Tron block, it executes a STF with new pending actions to update its local state copy. All locally executed blocks and actions are stored in the buffer;\nIf the STF execution resulted in closed orders, the Relayer passes them to the Fulfiller thread;\nThe Fulfiller thread calls calculateFulfillerTotal view function that returns the balance in USDT on ZKsync Era it must have, passing one order back in the buffer and re-calling the function until their balance is enough (if it wasn't enough since the first call);\nWith the number returned by calculateFulfillerTotal function, the Fulfiller thread calls fulfill function with those orders to transfer the USDT to the order creators;\nAfter the buffer has reached the size specified in the configuration, the Relayer generates a ZK proof for the STF with the buffer as the input;\nThe Relayer sends the ZK proof to the Core contract on ZKsync Era by calling closeOrders function;\nThe Core contract verifies the ZK proof and the public inputs, and if everything is correct, it marks all orders in the public inputs as closed and the Relayer repeats the process from step 3.\nWarning: Even though the situation of the Relayer's account not having enough USDT to fulfill orders is handled, the situation when the Relayer's ZKsync account doesn't have enough balance to pay for the gas of the closeOrders and fulfill calls is not handled and will cause things to go wrong."}},"/contribute":{"title":"Contribute to Untron","data":{"":"If you're here, you're probably interested in contributing to Untron. There are many ways to contribute, and we're grateful for any help. We've made a table that should help you decide how you can help:\nHow tech-savvy you are / Would you want to invest in Untron\tI can't invest\tI can invest some money into Untron and know how to earn spread\tI can invest a significant amount and/or don't know how to earn spread\tI'm not tech-savvy\tBe an ambassador! Try Untron out, recommend it to your friends, suggest wallets to integrate it.\tProceed to Untron.finance and provide liquidity there!\tContact us. Untron is always open for investments and provides liquidity management services for partners.\tI understood your documentation\tYou can write articles or threads on social media, or suggest us improvements or features.\tRebalance liquidity across Untron Intents to maximize your spread and equalize rates across them.\tIntegrate Untron into your projects and build new ones on top of Untron.\tI'm able to work with your codebase\tContribute to our codebase directly. With proof of work, there's some chance we could hire you.\tDevelop advanced trading strategies or tools to optimize your liquidity provision.\tIf you're an engineering team, contact us for development partnership opportunities.\t\nUntron is always looking for helping hands. We're also in the process of seeding the project, so if you're interested, please reach out to us."}},"/":{"title":"What's Untron?","data":{"":"Untron, or Untron.finance, is a unique marketplace-based platform that allows people to seamlessly send money between Tron and Ethereum ecosystems using USDT on Tron. It's powered by zero-knowledge (ZK) proofs of Tron blockchain, verifying the authenticity of all transactions happening there using advanced cryptography. This allows Untron to provide a secure and trustless environment for users to transfer funds without the need for intermediaries.At most conservative estimates, over 50 million people around the world use USDT on Tron Network to pay for goods and store life savings. However, the current state of Tron is deplorable. The network is totally centralized, expensive to use, and lacks the ecosystem around self-custody, forcing users to rely on centralized exchanges for their funds.In contrast, the Ethereum ecosystem continues to thrive. Following the Dencun upgrade, transaction fees on rollups have drastically decreased to less than a cent per ERC20 transfer. Combined with L2s, Ethereum DeFi now comprises >80% of the entire DeFi TVL. Rollups alone consistently handle upwards of 100 TPS, with theoretical limits of 400-800 TPS depending on the specific rollup. At the time of writing, OP Mainnet has upgraded to Stage 1 trustlessness with all OP Chains and ZKsync catching up. Arbitrum is working towards Stage 2.People in developed countries are already integrated with Ethereum. By allowing them to seamlessly move into it from Tron, we can unite these disparate ecosystems and mitigate the risks associated with increasing centralization and monopolization of Sun’s machine.Unlike existing, centralized bridges, Untron is trustless and marketplace-based. This means that Untron is akin to a peer-to-peer USDT-USDT exchange, where users can buy and sell USDT on Tron with crypto tokens in the Ethereum ecosystem at market-based prices. Fair competition of rates, in turn, lets users always get the best return.Powered by ZK proofs, Untron ensures that all orders in the system are secure and tamper-proof, as long as Ethereum and Tron are. Moreover, due to its two-way exchange-friendly design, Untron also lets people to send USDT on Tron from the Ethereum ecosystem wallets and receive it from any USDT TRC20 exchange.In short, Untron creates ideal conditions for Ethereum's vampire attack on Tron.The common misconception is that a vampire attack only requires one-way bridging to an objectively, as people think, better ecosystem. However, this is not true from the economic standpoint.In order for a better solution to gain the leader's market share, these two solutions must perfectly interoperate with each other. This would open free, unimpeded market within the ecosystem, allowing people to actually choose the solution which is better for them, not the one which has more users and adoption.This phenomenon is better known as the Network Effect, first applied in Metcalfe's Law. According to it, the value or utility a user derives from a good or service depends on the number of users of compatible products. In other words, the significant portion of the product's value comes from its adoption in the ecosystem. In our case, Tron's value doesn't come from its low fees, DeFi, or decentralization (none take place), but rather its high adoption in various countries and regions around the world. Dogan Alpaslan, the cofounder of Clave, has described applying this concept to the Tron ecosystem as the Tron's Network Effect, taking Africa and Turkish Cyprus as an example. Such examples, however, can be found all over the world, where USDT on Tron is still used.One-way bridging doesn't make two platforms compatible, as two users of those platforms can't utilize them to interact with each other. Specifically, there is no point in moving to, say, USDC on Base, if you can't send funds to your friends, most of which are still on USDT on Tron, even if the migration from Tron to Base is very cheap and straightforward.This is why only two-way bridges can perform a meaningful \"vampire attack\" on the ecosystem standing on its network effects."}},"/integrate/api":{"title":"Untron.finance API","data":{"":"TODO"}},"/integrate/contracts":{"title":"Untron from Contracts","data":{"":"Here's an example of how to interact with Untron Core from a Solidity smart contract deployed on ZKsync Era. In this example, we're creating a wrapper contract that allows its owner to manage orders on Untron, while keeping all collateral in the contract.\nWarning: This code was not audited and must not be used in production.\n// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {IUntronCore, Transfer} from \"@ultrasoundlabs/untron/contracts/src/interfaces/IUntronCore.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\ncontract UntronWrapper is Ownable {\n    IUntronCore public untron;\n    IERC20 public usdt;\n    constructor(address _untron, address _usdt) Ownable(msg.sender) {\n        untron = IUntronCore(_untron);\n        usdt = IERC20(_usdt);\n    }\n    function createOrder(address provider, address receiver, uint256 size, uint256 rate, Transfer calldata transfer)\n        external onlyOwner {\n        uint256 collateral = untron.requiredCollateral();\n        require(usdt.balanceOf(address(this)) >= collateral, \"Insufficient USDT balance\");\n        usdt.approve(address(untron), collateral);\n        untron.createOrder(provider, receiver, size, rate, transfer);\n    }\n    function changeOrder(bytes32 orderId, Transfer calldata transfer) external onlyOwner {\n        untron.changeOrder(orderId, transfer);\n    }\n    function stopOrder(bytes32 orderId) external onlyOwner {\n        untron.stopOrder(orderId);\n    }\n    function withdrawCollateral() external {\n        usdt.transfer(owner(), usdt.balanceOf(address(this)));\n    }\n}"}},"/integrate":{"title":"Integrate Untron","data":{"":"Even though Untron as the project strives to be cross-chain friendly and work in the entire Ethereum ecosystem, Untron V1 (Core) is deployed on ZKsync Era L2 network. To power interaction from other L2s, Untron Core natively supports Across bridge.","why-deploy-on-a-single-l2#Why deploy on a single L2?":"We believe that the only way to allow all Ethereum ecosystem users to have access to the best rates is to deploy on a single L2 network and integrate various interoperability protocols to power interaction from other L2s. When all liquidity is concentrated in a single L2, people from Base to Scroll to ZKsync can access the same rates.","why-zksync-era#Why ZKsync Era?":"We believe that ZK rollups and shared environments for validity L2s (Elastic Chain, AggLayer, etc.) will become the standard for Ethereum L2s, and ZKsync Era has advanced the most in this field. Deploying on ZKsync Era allows Untron to seamlessly interoperate with the entire Elastic Chain and minimize hurdles when interacting with other L2s outside it.In the long term, we're planning to build Untron V2—a (at this moment) concept of an intent-based exchange with USDT Tron that incorporates more Ethereum L1 logic. Untron V2 will replace V1, allow for even cheaper and faster swaps across more chains within the Ethereum ecosystem, and pave the way for automated static deposit addresses. More details about Untron V2 will be released in the future.","preparing-for-integration#Preparing for integration":"Untron Core is deployed as a standalone contract on ZKsync Era. It means that all smart contracts on ZKsync Era can interact with Untron Core.","core-deployments#Core Deployments":"Mainnet: not deployed yet\nSepolia Testnet: not deployed yet","dependencies#Dependencies":"All smart contract and interface source code is available on our GitHub repository:Forge: forge install ultrasoundlabs/untronGit Submodule: git submodule add https://github.com/ultrasoundlabs/untron.git...or just copy the /contracts/src/interfaces folder into your project.","interfaces#Interfaces":"In practice, you'll most likely interact with these functions from IUntronCore.sol:\n/// @notice Struct representing the liquidity provider in the Untron protocol\nstruct Provider {\n    // provider's total liquidity in USDT L2\n    uint256 liquidity;\n    // provider's current rate in USDT L2 per 1 USDT Tron\n    uint256 rate;\n    // minimum order size in USDT Tron\n    uint256 minOrderSize;\n    // minimum deposit in USDT Tron\n    uint256 minDeposit;\n    // provider's Tron addresses to receive the USDT Tron from the order creators\n    address[] receivers;\n}\nfunction providers(address provider) external view returns (Provider memory);\nfunction isReceiverBusy(address receiver) external view returns (bytes32);\nfunction maxOrderSize() external view returns (uint256);\nfunction requiredCollateral() external view returns (uint256);\n/// @notice The order creation function\n/// @param provider The address of the liquidity provider owning the Tron receiver address.\n/// @param receiver The address of the Tron receiver address\n///                that's used to perform a USDT transfer on Tron.\n/// @param size The maximum size of the order in USDT L2.\n/// @param rate The \"USDT L2 per 1 USDT Tron\" rate of the order.\n/// @param transfer The transfer details.\n///                 They'll be used in the fulfill or closeOrders functions to send respective\n///                 USDT L2 to the order creator or convert them into whatever the order creator wants to receive\n///                 for their USDT Tron.\nfunction createOrder(address provider, address receiver, uint256 size, uint256 rate, Transfer calldata transfer)\n    external;\n/// @notice Changes the transfer details of an order.\n/// @param orderId The ID of the order to change.\n/// @param transfer The new transfer details.\n/// @dev The transfer details can only be changed before the order is fulfilled.\nfunction changeOrder(bytes32 orderId, Transfer calldata transfer) external;\n/// @notice Stops the order and returns the remaining liquidity to the provider.\n/// @param orderId The ID of the order to stop.\n/// @dev The order can only be stopped before it's fulfilled.\n///      Closing and stopping the order are different things.\n///      Closing means that provider's funds are unlocked to either the order creator or the provider\n///      as the order completed its listening cycle.\n///      Stopping means that the order no longer needs listening for new USDT Tron transfers\n///      and won't be fulfilled.\nfunction stopOrder(bytes32 orderId) external;\n/// @notice Sets the liquidity provider details.\n/// @param liquidity The liquidity of the provider in USDT L2.\n/// @param rate The rate (USDT L2 per 1 USDT Tron) of the provider.\n/// @param minOrderSize The minimum size of the order in USDT Tron.\n/// @param minDeposit The minimum amount the order creator can transfer to the receiver, in USDT Tron.\n///                   This is needed for so-called \"reverse swaps\", when the provider is\n///                   actually a normal order creator who wants to swap USDT L2 for USDT Tron,\n///                   and the order creator (who creates the orders) is an automated entity,\n///                   called \"sender\", that accepts such orders and performs transfers on Tron network.\n///                   order creators doing reverse swaps usually want to receive the entire order size\n///                   in a single transfer, hence the need for minDeposit.\n///                   minOrderSize == liquidity * rate signalizes for senders that the provider\n///                   is a order creator performing a reverse swap.\n/// @param receivers The provider's Tron addresses that are used to receive USDT Tron.\n///                  The more receivers the provider has, the more concurrent orders the provider can have.\nfunction setProvider(\n    uint256 liquidity,\n    uint256 rate,\n    uint256 minOrderSize,\n    uint256 minDeposit,\n    address[] calldata receivers\n) external;\nAnd this struct from IUntronTransfers.sol (derived by IUntronCore):\n/// @notice Struct representing a transfer.\nstruct Transfer {\n    // recipient of the transfer\n    address recipient;\n    // destination chain ID of the transfer.\n    // if not equal to the contract's chain ID, Across bridge will be used.\n    uint256 chainId;\n    // Across bridge fee. 0 in case of direct transfer.\n    uint256 acrossFee;\n    // whether to swap USDT to another token before sending to the recipient.\n    bool doSwap;\n    // address of the token to swap USDT to.\n    address outToken;\n    // minimum amount of output tokens to receive per 1 USDT L2.\n    uint256 minOutputPerUSDT;\n    // whether the minimum amount of output tokens is fixed.\n    // if true, the order creator will receive exactly minOutputPerUSDT * amount of output tokens.\n    // if false, the order creator will receive at least minOutputPerUSDT * amount of output tokens.\n    bool fixedOutput;\n    // data for the swap. Not used if doSwap is false.\n    bytes swapData;\n}\nThey're pretty nicely commented, but here's a quick summary:\nproviders is a mapping of providers. Provider struct contains a bunch of information we'll need to construct inputs for createOrder.\nmaxOrderSize is the maximum size of the order in USDT Tron. Unlike minimum order size unique to each provider, this is a protocol-enforced global limit for all providers.\nrequiredCollateral is the minimum amount of USDT ZKsync that must be approved to Core contract to create an order. These USDT will be temporarily locked in Core contract until the order is fulfilled or stopped.\ncreateOrder is used to create an order. To construct its input, we have to find a provider that has enough liquidity for our order, and fetch some of the inputs from providers function. Then, we build a Transfer struct, specifying in what form we want to receive the USDT for the order.\nchangeOrder is used to change Transfer from not yet fulfilled order. This is needed in case there was large slippage from initial swap parameters, and current Transfer can't be fulfilled given amount of USDT ZKsync output from the order.\nstopOrder is used to stop a not yet expired (5 minutes) order. This must only be used in case no USDT Tron was sent to the order receiver, because it removes information about the order from the state. After the receiver is claimed by some other order, the expired order is automatically stopped by the protocol, but its creator gets their collateral slashed. Therefore, you might want to stop orders before they expire, to avoid losing funds.\nsetProvider is used to set the liquidity provider details. You might need this to either provide liquidity for Untron. Unlike createOrder, this function does not require collateral.\nWe have built an open-source Untron Indexer that indexes Untron Core and provides a local endpoint to find best rates at your order size. If you don't have an option or don't want to run your own indexer, you can use Untron.finance's API that incorporates this indexer.","transfer-struct#Transfer Struct":"Transfer struct is used to specify in what form we want to receive the USDT for the order. It has the following fields:\nrecipient is the address that will receive the funds for the order, sometimes referred to as an \"order beneficiary\".\nchainId is the ID of the chain to which we want to send the USDT. If it's not equal to the chain ID of the contract (324 for Era Mainnet), Across bridge will be used. Therefore, this chain ID must either be equal to the host chain, or supported by Across.\nacrossFee is the fee for Across bridge. It's 0 in case of transfer within ZKsync Era. You must fetch this value from Across API, but at the time of writing, Across takes 0.05% fee on L2->L2 USDT transfers.\ndoSwap is a flag whether we want to swap USDT to another token before sending to the recipient.\noutToken is the address of the token to swap USDT to. In case Across is used, it must be supported by Across.\nminOutputPerUSDT is the minimum amount of output tokens to receive per 1 USDT L2. This is used to set slippage for the swap.\nfixedOutput is a flag whether the minimum amount of output tokens is fixed. If true, the order creator will receive from the fulfiller exactly minOutputPerUSDT * amount of USDT L2 output tokens. If false, the order creator will receive at least this amount. If the order is fulfilled by a relayer (via closeOrders) and not by the fulfiller, this is automatically set to false.\nswapData is a bytes field that is used to pass additional data for the swap. As Untron Core uses 1inch V6 Aggregator, you should construct this data from their API/SDK. If swaps are not used, this should be left empty.\nFor more information about integrating Across, see their docs. 1inch V6 has a Developer Portal, where you can find more information about their API.If you'd like to integrate Untron into your project but your business workflow doesn't allow you to work with Core and create orders directly, please reach out to us. We can discuss a custom integration."}},"/integrate/software":{"title":"Untron from Software","data":{"":"Here's an example of how to create an order in Untron using Python and Untron.finance API. We'll use zksync2-python library, deriving from Web3.py, to interact with the smart contract. Instead of API, you can also host your own Untron Indexer.\nWarning: This code was not audited and must not be used in production.\nfrom eth_account import Account\nfrom eth_account.signers.local import LocalAccount\nfrom web3.types import TxParams\nfrom zksync2.core.types import EthBlockParams\nfrom zksync2.module.module_builder import ZkSyncBuilder\nfrom zksync2.transaction.transaction_builders import TxFunctionCall\nimport json\nimport requests\n# Constants\nAPI_URL = \"https://api.untron.finance/v1/best-provider\"\nUNTRON_CORE_ADDRESS = \"0x...\"  # Replace with actual Untron Core contract address\nCHAIN_ID = 324  # ZKSync Era\nUSDT_ADDRESS = \"0x...\"  # Replace with actual USDT contract address on ZKSync Era\n# Connect to ZKSync Era network\nzk_web3 = ZkSyncBuilder.build(\"https://mainnet.era.zksync.io\")\n# Load the Untron Core contract ABI.\n# To generate it, you need to compile untron using foundry-zksync or other compilation tool.\nwith open('untron/contracts/zkout/UntronCore.sol/UntronCore.json', 'r') as abi_file:\n    untron_core_abi = json.load(abi_file)\n# Create contract instances\nuntron_core = Contract(UNTRON_CORE_ADDRESS, untron_core_abi)\nusdt_contract = zk_web3.eth.contract(address=USDT_ADDRESS, abi=ERC20_ABI)  # Assuming you have ERC20_ABI defined\ndef get_best_provider(size):\n    \"\"\"Get the best provider, receiver, and rate for the given order size.\"\"\"\n    params = {\n        'size': size\n    }\n    response = requests.get(API_URL, params=params)\n    if response.status_code == 200:\n        data = response.json()\n        return data['provider'], data['receiver'], data['rate']\n    else:\n        raise Exception(f\"API request failed with status code {response.status_code}\")\ndef get_required_collateral():\n    \"\"\"Get the required collateral amount from Untron Core.\"\"\"\n    return untron_core.functions.requiredCollateral().call()\ndef approve_erc20(account: LocalAccount, amount: int):\n    \"\"\"Approve ERC20 token spending.\"\"\"\n    nonce = zk_web3.zksync.get_transaction_count(\n        account.address, EthBlockParams.LATEST.value\n    )\n    approve_tx = usdt_contract.functions.approve(\n        UNTRON_CORE_ADDRESS,\n        amount\n    ).build_transaction({\n        'chainId': CHAIN_ID,\n        'nonce': nonce,\n        'from': account.address,\n        'gas': 0,  # Let the network estimate this\n        'gasPrice': zk_web3.zksync.gas_price\n    })\n    estimated_gas = zk_web3.zksync.eth_estimate_gas(approve_tx)\n    approve_tx['gas'] = estimated_gas\n    signed_tx = account.sign_transaction(approve_tx)\n    tx_hash = zk_web3.zksync.send_raw_transaction(signed_tx.rawTransaction)\n    tx_receipt = zk_web3.zksync.wait_for_transaction_receipt(\n        tx_hash, timeout=240, poll_latency=0.5\n    )\n    return tx_receipt\ndef create_order(account: LocalAccount, size: int):\n    \"\"\"Create an order in Untron Core.\"\"\"\n    provider, receiver, rate = get_best_provider(size)\n    # Create Transfer struct.\n    # We're performing a simple swap to USDT on ZKsync, so most fields are empty.\n    transfer = {\n        'recipient': account.address,\n        'chainId': CHAIN_ID,\n        'acrossFee': 0,\n        'doSwap': False,\n        'outToken': '0x0000000000000000000000000000000000000000',\n        'minOutputPerUSDT': 0,\n        'fixedOutput': False,\n        'swapData': b''\n    }\n    nonce = zk_web3.zksync.get_transaction_count(\n        account.address, EthBlockParams.LATEST.value\n    )\n    calldata = untron_core.encode_method(fn_name=\"createOrder\", args=[provider, receiver, rate, size, transfer])\n    eth_tx: TxParams = {\n        \"from\": account.address,\n        \"to\": untron_core.address,\n        \"data\": calldata,\n    }\n    eth_ret = zk_web3.zksync.call(eth_tx, EthBlockParams.LATEST.value)\n    result = int.from_bytes(eth_ret, \"big\", signed=True)\n    gas_price = zk_web3.zksync.gas_price\n    func_call = TxFunctionCall(\n        chain_id=CHAIN_ID,\n        nonce=nonce,\n        from_=account.address,\n        to=untron_core.address,\n        data=calldata,\n        gas_limit=0,\n        gas_price=gas_price,\n    )\n    estimate_gas = zk_web3.zksync.eth_estimate_gas(func_call.tx)\n    tx_712 = func_call.tx712(estimate_gas)\n    singed_message = account.sign_typed_data(tx_712.to_eip712_struct())\n    msg = tx_712.encode(singed_message)\n    tx_hash = zk_web3.zksync.send_raw_transaction(msg)\n    tx_receipt = zk_web3.zksync.wait_for_transaction_receipt(\n        tx_hash, timeout=240, poll_latency=0.5\n    )\n    return tx_receipt\n# Example usage\nprivate_key = \"0x...\"  # Replace with the actual private key\naccount: LocalAccount = Account.from_key(private_key)\norder_size = 100_000_000 # 100 USDT Tron\ntry:\n    # First, approve the USDT spending for collateral\n    required_collateral = get_required_collateral()\n    approve_receipt = approve_erc20(account, required_collateral)\n    print(f\"ERC20 approval successful. Transaction hash: {approve_receipt['transactionHash'].hex()}\")\n    # Then, create the order\n    receipt = create_order(account, order_size)\n    print(f\"Order created successfully. Transaction hash: {receipt['transactionHash'].hex()}\")\nexcept Exception as e:\n    print(f\"Error creating order: {str(e)}\")"}},"/navigation":{"title":"Getting Started","data":{"":"If you want to use Untron, check out your wallet. There is some chance it supports Untron natively. If not, reach out to us, and we will try our best to get it added. In the meantime, you can use Untron.finance, the official decentralized interface for Untron, to bridge your assets. It supports dozens of wallets and networks, but if something feels wrong to you, please reach out to us.If you want to learn more about how Untron works inside, check out the How Untron Works section.If you want to integrate Untron into your project, check out the Integrate Untron section.If you want to contribute to Untron, check out the Contribute to Untron section.","our-team#Our Team":"Untron was built by Ultrasound Labs, a team of genius engineers and researchers who are passionate about making blockchain technology more accessible and secure.\nAlex Hook — Founder, inventor and lead engineer of Untron;\nZiemen — Cofounder & research lead, engineer of Untron;\nAlex Kuzmin — Cofounder, design & branding lead;\nWizdom — Research & infrastructure.\nNote: All people listed here are directly related to the development of Untron Protocol. Some members of the team are working on Untron.finance, the official frontend for Untron, which is considered a separate project and not related to these docs."}}}